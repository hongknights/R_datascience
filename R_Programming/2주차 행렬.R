x <- matrix(1:12, 3, 4); x #a부터 b까지의 수(a:b)를 가지고 3행 4열의 행렬 저장
matrix(1:12, 3, 4)
x <-matrix(1:12, 3, 4, byrow=T); x #byrow 옵션은 1행부터 원소를 채우느냐에 대한 옵션, byrow=F가 기본값(defualt)이다

rownames(x) ; colnames(x) #행의 명칭과 열의 명칭이 부여가 됬는지 확인

x <-matrix(1:12, 3, 4, byrow=T); x 
rownames(x) <- c("행1", "행2", "행3") #이름이 없는 행렬 중 행에 명칭 부여
colnames(x) <- c("열1", "열2", "열3", "열4")
x

x <- matrix(1:15, 5, 3)
x
t(x) #5x3 행렬이 3x5 행렬로 변환됨, 고로 행과 열의 수를 바꿈
y <- as.vector(x); y #열로 구분해서 벡터로 저장
z <- as.vector(t(x)); z #t는 전치행렬(TRASPOSE MATRIX) , 전치 행렬을 열로 구분해서 벡터로 저장

x <- matrix(1:6, 2,3) ; x
y <-matrix(c(2,0, -1, 3, 4, -2), 3, 2); y
x %*% y #행렬 x와 y의 곱 (행렬의 곱이 정의되어야함)
x %*% t(x) #행렬 x와 전치행렬 t(x)의 곱 , %*% 반드시 붙여서 사용
3*y #행렬의 스칼라 배, 모든 원소의 3배
x + t(y)  #행렬 x와 t(y)의 덧셈  ,  두 행렬의 모양이 같아야 함
y*y #행렬의 각 원소 제곱


 z <- matrix(c(1, -1, 5,2,1,0, -3, 0, 1, 4, -3, 0), nrow=4, byrow=T) ; z #행의 크기 = 4 , 고로 열의 크기는 알아서 맞춰짐
 z[3,2] #z의 3행 2열 성분을 출력 [행의 위치, 열의 위치]
 z[1, ]; z[ ,3] # 1행을 모두 출력 / 3열을 모두 출력
 z[-2, ]; z[2 , -3] # 2행을 제외한 모든 행을 출력 / 3열의 제외한 열을 모두 출력
 z[ , 2:3] # 2열부터 3열까지  모두 출력
 z[ ,2, drop=F] # 행과 열을 출력할떄, 행렬의 형태를 보존해서 출력 ( = "drop=F")
 dim(z) #dim 은 dimension의 약자, 행렬 z의 사이즈 행과 열의 크기 출력
 dim(z)[1] # 행렬 z의 행의 크기 출력
 dim(z)[2] # 행렬 z의 열의 크기 출력
 dim(z)[3] # NA(= 없는 값, 사용할 수 없음)를 출력

 rowSums(z) # 모든 행의 합을 출력
 colSums(z) # 모든 열의 합을 출력
 rowMeans(z) # 모든 행의 평균을 출력
 colMeans(z) # 모든 열의 평균을 출력
 apply(z, 1, sum) #행렬 z의 모든 행들의 합을 출력
 apply(z, 2, sum) #행렬 z의 모든 열들의 합을 출력
 apply(z, 1, mean) #행렬 z의 모든 행들의 평균을 출력
 apply(z, 2,mean) # 행렬 z의 모든 열들의 평균을 출력
 
 
 x1 <- c(1, -1, 3); y1 <- c(0, 4, 2)
 m1 <- rbind(x1, y1); m1 #x1, y1 벡터를 행으로 결합, x1은 1행, y1은 2행
 
 m1 <- rbind(c(1, -1, 3), c(0, 4, 2)); m1 #2x3 행렬
 
 x2 <- c(1, -1, 3); y2 <- c(0, 4, 2)
 m2 <- cbind(x2, y2) ; m2 #x2, y2 벡터를 열로 결합, x2은 1열, y2는 2열
 
 m2 <- cbind(c(1, -1 , 3), c(0, 4, 2)); m2  #3x2 행렬